物理内存管理
	页面内存管理
		linux把物理内存划分若干大小相同（通常为4k)的页面，每个页面使用struct page描述，在内核初始化时会跟据物理内存大小也和页面大小，初始化一个struct page数组mem_map对系统中所有的页面进行统一管理。

	物理页面描述
		使用node、zone、page三级结构进行管理
		每个node中有三个zone，分别为DMA，normal和higtmem，DMA为3G开始16M地址空间，
		Page是内核物理内存管理的最小单位，包含各种该页面内存的状态信息，分配状况。

		物理页面分配
		以2的N次方个页面单位进行内存分配，主要解决外部碎片问题。

	页面回收
		内存中并非所有物理页面都是可以进行回收的，内核占用的页不会被换出，只有与用户空间建立映射关系的物理页面才会被换出，
			进程映射所占有页面，包括代码段、数据段、堆栈已经动态分配的堆。
			使用mmap把文件内容映射到内存所占的页面
			tmpfs文件系统使用的页

		回收时机
			周期性检查，后台守护进程kswapd 完成，该进程定期检查当前系统内存使用情况，当发现系统空闲的物理页面数目少于特定的阀值时，该进程就会发起页面回收的操作。

			内存严重不足事件触发。

	swap内存管理
		在低速磁盘选定一块空间，以页面大小通常为4K为单位划分空间，以页面为单位进行管理

	虚拟内存管理
		内核态虚拟内存管理
		内核态虚拟内存分配
			使用slab分配器，(嵌入式系统使用轻量级slub分配器， 大型服务器使用支持大量大内存分配slob分配器)，主要解决外部碎片问题。

			再此基础上穿件一些列的页面缓存。

			kmalloc使用slab创建一些2的N次方大小为单位的页面进行内存分配，所以分配的内存的物理连续的。且地址空间位于Normal Zone。

			vmalloc和kmalloc使用的分配方法稍微有不同，分配的内存可能是不连续的，且映射在highmem zone

	查看书籍进一步了解内存分配和使用机制。

linux设备驱动程序
	内存映射和DMA

	linux内存是一个虚拟内存系统，这意味着用户程序使用的地址与硬件使用的物理地址是不等同的。虚拟内存引入一个间接层，有了虚拟内存，在系统程序可以分配比物理内存更多的内存。

	linux地址类型
		用户虚拟地址
			用户程序所能看到的常规地址。
		物理地址
			改地址在处理器和系统内存之间。
		总线地址
			通常与处理使用的物理地址相同，有的处理器提供IO内存管理单元，进行总线和主内存之间重新映射、
		内核逻辑地址 
			内核态使用kmalloc返回的内存就是内核逻辑地址。
		内核虚拟地址
			和逻辑地址相同的是都是将内核空间的地址映射到物理地址之上，为扩充内存。
			vmalloc和kmap函数返回一个内核虚拟地址。



		物理地址和页
			物理地址被分成离散的单元称为页。内存地址由页号和页内偏移量 如使用页大小是4K 那么最后12为表示页的偏移量，而剩余高位为页号。

		低端内存和高端内存
			32系统能在4GB的内存中寻址。将4GB的地址分为内核空间和用户空间。
			低端内存 存在于内核空间上的逻辑地址内存。
			高端内存 不存在逻辑地址的内存，这是因为处于内核虚拟地址之上，

		内存映射和页结构
			管理内存的page结构
				atomic_t  count 
					引用计数， 当数值为0时，表示页将返回给空闲链表。
				void *virtual
					页面是否被映射， 低端内存总是被映射， 高端内存存在映射，只在内核空间使用.
				unsinged long flag
					页状态的一系列标志。PG_locked表示内存页已经被锁住。

		页表
			将虚拟地址转换为相应的物理地址。

		mmap将用户空间的一段内存与设备内线管理起来，任何针对该内存的操作都映射到设备。必须以pase_size为单位进行映射。内存以页表为管理单位
		比如PCI外围设备都是将寄存器映射到内存，而不是通过ioctl去获得必要信息。
		思考如何实现：我们使用的内存是虚拟地址，mmap只是将内存映射到设备对应的物理地址。

		内存读写速度快。

linux内核针对物理内存的操作接口很多


