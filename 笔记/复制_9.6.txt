复制
	redis 可以通过slaveof或者配置slaveof选项，让一个服务器去replicate另一个服务器，我们称被复制的主服务器为master，而对主服务器进行复制的服务器称为从服务器slave。

	进行复制的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作数据库状态一致

	主从复制的断点续传
	主从复制的实现原理
	主从复制的心跳机制实现原理。


	同步
		从服务器对主服务器的同步操作步骤：
		1、从服务器向主服务器发送SYNC命令。
		2、收到SYNC的主服务器执行BGSAVE命令，在后台生存RDB文件，并使一个缓冲区记录从现在开始执行的写命令。
		3、主服务器开始发送RDB文件，从服务器载入RDB文件。
		4、主服务器将所有的写命令发送给从服务器。从服务器本地执行写命令。
	命令传播：
		同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但是主服务器需要将写命令传递给从服务器。

	新版本复制功能实现
		为了解决旧版本复制功能在处理断线重复复制情况时的低效问题，redis从2.8版本开始使用psync命令代替SYNC命令来执行复制时的同步操作。
		PSYNC命令具有完整重同步和部分重同步两种模式。
		完整同步就是将数据RDB文件完全同步
		部分同步用于处理断线后复制情况。
		部分重同步由以下三个部分构成
		1、主服务器的复制偏移量和从服务器的复制偏移量。
		2、主服务器的复制积压缓冲区。
		3、服务器的运行ID

		复制偏移量
			主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N
			从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N
		复制积压缓冲区
			固定长度的先进先出队列，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量
			当从服务器连接上主服务器时，从服务器通过psync命令将自己的复制偏移量offset发送给主服务器。
			偏移量是否在复制缓冲区 ，
			复制积压缓冲区 = 断线重连时间 * write_size_per_second,进行评估。
		服务器运行ID
			每个redis服务器，都会有自己的运行ID，
			从服务器记录主服务器的ID，每次断线重连需要发送主服务器的ID，如果相同，则是断线重连。

			第一次：如果从服务器没有复制过任何主机PSYNC ? -1
			或者PSYNC <runid> <offset>
			+FULLRESYNC <runid> <offset> 从新完整性同步
			+CONTINUE 断点续传
			+ERR 主服务器不支持PSYNC


			步骤1：设置主服务器的地址和端口
				SALVEOF 命令设置 redisServer的 主服务器地址（masterhost）和端口（masterport），后直接返回，实际的工作在OK返回之后才正真开始执行。
			步骤2：建立套接字连接
			步骤3：发送PING命令
					从服务器成为主服务器之后，做的第一件事情就是想主服务器发送一个PING命令。
					作用：
						验证读写状态是否正常
						检查主服务器是否能正常处理命令。
					收到Pong回复， 如果timeout，则网络不佳或服务器忙返回BUSY，都需要断开连接重新创建套接字
					其他情况正常。
			步骤4：身份验证
					所有错误情况都会令从服务器中止目前的复制工作，并重新穿件套接字开始执行复制。

			步骤5：发送端口信息
			步骤6：同步
			步骤7：命令传播

		心跳检测
			在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：
			其中replication_offset是从服务器当前复制偏移量
				REPLCANF ACK replication_offset
			检测主从服务器的网络连接状态
			辅助实现min-slaves选项
			检测命令丢失
			INFO replication 查看主从状态

			min-slaves-to-write 3
			min-slaves-max-lag 10 
			如果从服务器少于三个，或者三个从服务器的延迟lag大于等于10秒拒绝执行写命令。
			检测命令丢失， 如果传递的offset和当前服务器的不一致，检测积压缓冲区对应偏移量。
sentinel哨岗 哨兵
	redis高可用性的解决方案：由一个或多个sentinel实例组成的sentinel系统，可以监视任意多个主服务程序以及这些主服务器属下的所有从服务器，并在监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后又新的主服务器代替已下线主服务器继续处理命令请求

	故障转移：
		1、sentinel系统会挑选其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器
		2、sentinel系统向从服务器发送新的复制命令，让他们成为新的主服务器的从服务器。当从服务器开始复制时，故障转移完毕
		3、sentinel还会监视下线的主服务器，并在他上线是设置为为新的主服务器的从服务器。

	启动sentinel系统
		redis-sentinel /path/to/your/sentinel.conf
		或
		redis-server /path/to/your/sentinel.conf --sentinel

		执行：
		1、初始化服务器
		2、将普通的redis服务器使用代码替换成sentinel专用代码
		3、初始化sentinel状态
		4、根据给定的配置文件，初始化sentinel的监视主服务器列表
		5、创建连向主服务器的网络连接。


		初始化服务器
			sentinel本质上只是一个运行在特殊模式下的redis服务器，所以启动sentinel的第一步就是初始化一个普通的redis服务器。
			sentinel执行的工作和普通redis服务器执行的工作不同，所以初始化过程并不完全相同。
			比如不会载入RDB和AOF文件初始化数据库
			sentinel的专用代码
		初始化sentinel状态
			在应用了sentinel的专用代码之后接下来服务器会初始化一个sentinel.c/sentinelState结构，这个结构保存了服务器中所有和sentinel有关状态

			struct sentinelState {
				//当前纪元
				uint64_t current_epoch;
				//主服务器
				dict *masters;

				int tilt;
				int running_scripts;
				mstime_t previous_time;
				list *scripts_queue;
			}

			sentinel默认会以每10秒一次的频率，通过命令连接向北监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。
			分写info返回信息
				主服务器本身信息run_id以及role域记录得服务器角色。
				主服务器下面的从服务器信息 ip port自动发现从服务器，更新slaves字典
				并根据本地是否存在，更新slaves字典
				创建新的从服务器的命令连接和订阅连接
			检测主观下线状态
				sentinel会以每秒一次的频率向所有与它创建了命令连接的的实例（主服务器、从服务器、其他的sentinel在内）发送ping命令。
				有效回复：+PONG,-LOADING/-MASTERDOWN三种回复的其中一种
				无效回复：其他

			如果在down-after-millisecond毫秒内连续返回无效回复，则设置结构体flags SRI_S_DOWN.
			当sentinel将服务器判断为主观下线之后，会对其他sentinel进行询问，当接收到足够数量的已下线判断之后，sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移。

			选举领头sentinel
				选举领导 sentinel is-master-down-by-addr + ID
				如果本地未设置头的话 会将ID设置为自己的局部领头
				然后接受命令回复的sentinel将会根据这一回复，统计出游多少个sentinel将自己设置为局部领头。 根据发送命令的先后顺序不一样。
				选出主服务器，其他从服务器发送slaveof no one，然后以每秒一次的频率向新的master发送info命令知道转台有slave变成master。然后让从服务器去复制新的主服务器。
				因为旧的主服务器已经下线，所以这种设置的是保存在旧主服务器对应实例结构里面的，从新上线时，发送slaveof命令成为从机。

	总结： 通过配置文件 创主服务器
			通过info 获取主服务器的从服务器 创建连接和订阅。
			通过订阅发送 其他sentinel， 创建命令连接。
			通过每秒一次ping和回复pong来判断实例是否在线，
			主观下线它会像同样监控这台主服务器的其他sentinel进行询问
			当收集到足够多的主观下线投票后， 他们将主服务器判断客观下线， 然后选举出主sentinel，对主服务器进行故障转移


















