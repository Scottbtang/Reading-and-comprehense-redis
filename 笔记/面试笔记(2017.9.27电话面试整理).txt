问题1：ngxin负载均衡如何实现？
	nginx的upstream目前支持4种方式的分配
	1、轮询(默认)
		每个请求按照顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
	2、 权重weight
		指定轮询几率，weight和访问比例成正比，用于后端服务性能不均的情况。
	3、ip_hash
		每个请求按访问ip的hash结果分配，这样每个访问固定访问一个后端服务器，可以解决session的问题
	4、fair(第三方)
	5、url_hash

	如何实现多台服务器之间session的共享
	1、不使用session，换做cookie
	2、应用服务器自行实现
	3、ip_hash

问题2：const和staic的区别和用处？
	const总结
		1、常对象  const 类名 对象名
		例如： const Cdate d1(2008, 8);
		d1是常对象，对象d1中的所有成员值不能修改，定义常对象必须要有初值，如果对象定义成常对象，不能调用非const成员函数，只能访问const成员函数，如果成员函数访问常对象，需要将函数声明为const。
		2、指针常量
		例如：int* const p=&a;
		指针P的值是不可以修改的
		所以指针常量必须在声明时初始化，指定一个地址的值。
		3、常量指针
		例如：const int *p；
		指针P的值可以修改，就是说可以指向另外的常量。
		4、函数参数const
		函数体内不能修改参数的值
		5、函数返回值为const
		函数返回值为const引用，即函数不能被修改，将const赋给另外一个const引用才有意义
		6、常数据成员变量
		const int age;
		常数据成员的值不能改变，只能通过构造函数的初始化列表对常数据成员进行初始化，而不能采用一般的在构造函数中复制实现。
		Student::Student(int a):age(a){};
		Student::Student(int a) {
			age = a //错误 
		}
		7、常成员函数
		void print() const; 
		常成员函数函数只能访问本类的数据成员(包括const和非const数据成员)，但是不能修改他们的值，只有常成员函数才可以操作常量或常对象。

	static总结
		1、静态局部变量： 静态局部变量始终存在，生存期为整个源程序，作用域和局部变量一样，静态局部变量会被自动的初始化为0.
		2、静态全局变量：静态全部变量只能在一个文件中使用。
		3、静态数据成员变量，描述整个类的特征，是整个类的成员，而不是一个对象的成员。
			初始化静态数据成员在类体外进行，
		4、静态成员函数 属于整个类的成员函数，是整个类的成员，而不是一个对象的成员，它的调用形式可以用对象来调用它，也可以用类的名字来调用它。 
			静态成员函数没有this指针，可以直接访问该类的静态成员和静态成员函数，而不能直接访问非静态成员变量和非静态成员函数。

		C语言中static作用
		static变量：
			1、隐藏
			2、保持变量内容的持久。
			3、默认初始化为0。
		static函数（也叫内部函数）只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用。

问题3：进程和线程的区别
	一个程序至少是一个进程， 一个进程至少有一个线程。
	线程的划分尺度小于进程，使得多线程程序的并发性高。

	另外，进程在执行过程中有独立的内存单元，而多线程共享内存，从而极大提高程序运行效率。
	线程在执行过程中与进程还是有区别的，每个独立的线程有个

	定义：
		进程是具有独立功能的程序关于某个数据集合上的一次运动活动，进程是系统资源分配和调度的一个独立单位。

		线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但它可以与同属一个进程的其他的线程共享进程所拥有的全部资源。

		区别：
		进程和线程的主要差别在于他们是不同的操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，不会对其他进程产生影响，而线程只是一个进程中的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉等于整个进程死掉，所以多进程要比多线程程序健壮，但是在进程切换时，资源消耗较大，效率差一些，单对于一些要求同时进行并且需要共享某些变量的并发操作，只能用线程，不能用进程。
		1、一个程序至少有一个进程，一个进程至少有一个线程。
		2、线程的划分尺度小于进程，使得多线程并发性高。
		3、进程在执行过程中拥有独立的内存单元，而多线程共享内存，从而极大地提高了程序的运行效率。
		4、线程在执行过程中与进程还是有区别的，每个独立的进程有一个程序入口、顺序的执行序列和程序的出口，单线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
		5、从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以并发执行。
问题4：程序在内存中的分布
	低地址->高地址：代码段、数据段、BBS，堆、栈
	代码段：文本段，存放着程序的机器码和只读数据。可执行指令就是这里取得的，如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码，任何对该区的写操作都会导致段错误。

	数据段：包括已经初始化的数据段和未初始化的数据段BBS，前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的为初始化变量，数据段在编译时分配。

	堆栈段：
		堆(heap):
			用来存储程序运行时分配的变量。
			堆的大小并不固定，可动态扩展和缩减，由malloc和new等实时内存分配函数来实现。通过free或delete进行释放。
		栈(stack):
			是一种用来存储函数调用时的临时信息的结构，如果函数调用所传递的参数、函数的返回地址、函数的局部变量等，在运行时有编译器需要时候分配，在不需要自动清除。
			栈的特性：最后方式栈的最先被拿出来。

			1.分配和管理方式不同 ：
           		堆是动态分配的，其空间的分配和释放都由程序员控制。
           		栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。
					静态分配由编译器完成，比如局部变量的分配。
					动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。
			2.产生碎片不同
          		对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。
          		对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。
			3.生长方向不同
				堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。
          		栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长

问题5:epoll的触发方式？
	LT：水平触发，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。

	ET：边缘触发，效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。
	与LT相比，ET模型是通过减少系统调用来达到提高并行效率的。

	select的特点：select 选择句柄的时候，是遍历所有句柄，也就是说句柄有事件响应时，select需要遍历所有句柄才能获取到哪些句柄有事件通知，因此效率是非常低。但是如果连接很少的情况下， select和epoll的LT触发模式相比， 性能上差别不大。
	
	epoll的特点：epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的。

问题6：指针和引用的区别？
	1、指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。
	2、可以有const指针，但是没有const引用；
	3、指针可以有多级，但是引用只能是一级；
	4、指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
	5、指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
	6、"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
问题7：C++如何实现多态？
	1、用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。
	2、存在虚函数的类都有一个一维的虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
	3、纯虚函数是虚函数再加上= 0。
	4、抽象类是指包括至少一个纯虚函数的类。

问题8：redis 如何让实现？选举算法？备份？持久化？故障转移？集群。


问题9: nginx 实现方式？

memcached和redis性能对比？
	1、redis memcache都是空的时候
	    redis设置100000个值开始时间:1311742106
	    redis设置100000个值时间:1311742123 耗时:16.8817
	    memcache设置100000个值开始时间:1311742123
	    memcache设置100000个值结束时间:1311742138 耗时:15.2574

	2、redis和memcache有数据时：
	    redis设置100000个值开始时间:1311742721
	    redis设置100000个值时间:1311742738 耗时:17.3401
	    memcache设置100000个值开始时间:1311742738
	    memcache设置100000个值结束时间:1311742753 耗时:15.6892
	 写入和获取时性能差别不大，和数据格式相关，差别不大。redis支持数据操作方式更多。
	 memcache使用gets和sets进行锁操作。